# Linux基础入门教程

内容包含：Linux命令、vim、gcc/g++、动态库/静态库、makefile、gdb调试

课程连接：https://www.bilibili.com/video/BV13U4y1p7kB/?spm_id_from=333.337.search-card.all.click

## 1 初识Linux操作系统

### 1.1 Linux的诞生

- Linux是一个基于文件的操作系统
- 发音：第一种：里拉克丝 第二种：里纽克斯

### 1.2 一些名词

- GNU：Gnu's Not Umix。可以理解成一种口号，号召软件自由。
- GPL：General Public License.GNU通用公共许可证。
- POSIX:是一套开发标准，POSIX标准是对UNIX操作系统的经验和实践发总结。对操作系统调用的服务接口进行了标准化，保证所编制的应用程序再源代码一级可以在多种操作系统上进行移植。

### 1.3 Linux发行版

debian\ubuntu\centos\redhat(收费)

### 1.4 Linux内核

Linux分为内核空间和用户空间两部分。Linux内核主要由5个子系统组成，分别是进程调度、内存管理、虚拟文件系统、网络接口、进程间通信。

**进程调度**

进程调度指的是系统对进程的多种状态之间转换的策略。Linux下的进程调度有3种策略：SCHED_OTHER、SCHED_FIFO 、SCHED_RR。

- SCHED_OTHER：分时调度策略（默认），是用于针对普通进程的时间片轮转策略。
- SCHED_FIFO:实时调度策略，是针对运行的实时性要求比较高、运行时间短的进程调度策略。
- SCHED_RR:实时调度策略，是针对实时性要求比较高、运行时间比较长的进程调度策略。

**内存管理MMU**

- 内存管理是多个进程间的内存共享策略。在Linux中，内存管理主要说的是虚拟内存。
- 虚拟内存可以让进程拥有比实际物理内存更大的内存，可以是实际内存的很多倍。
- 每个进程的虚拟内存有不同的地址空间，多个进程的虚拟内存不会冲突。

**虚拟文件系统VFS**

在Linux下支持多种文件系统,目前最常用的文件格式是ext2和ext3。

**网络接口**

网络接口分为网络协议和驱动程序。

**进程间通信**

Linux的进程间通信方式主要有：管道、信号、消息队列、共享内存和套接字等。

## 2 Linux目录

整个文件系统是树状的结构，Linux每增加一个文件，系统都会将其加入到树中。

### 2.1 文件目录结构

**/：**根目录

**bin:**可执行的二进制文件

**sbin:**给root用户用的可执行二进制文件

**dev:**设备文件

**home:**普通用户家目录

**lib\lib4:**存储操作系统中需要加载的动态库或者静态库

**mnt、media:**用于挂载外设

**proc、run：**操作系统运行中用到的目录，用户不要碰她

**tmp:**临时目录，操作系统重启后文件消失

**usr:**unix system recouces。unix的系统资源文件。

**boot:**存储开机项

**etc:**存储配置文件的目录

**opt:**安装第三方软件的目录。同usr中的local。

**var:**用来存储系统中常用并且常发生变化的文件，比如日志文件。

### 2.2 相对路径

相对于当前文件的目录。

- ./:代表当前所在的目录，也可以使用.表示。
- ../:代表当前目录的上一级目录，也可以使用..表示。

### 2.3 绝对路径

从系统盘起始节点开始描述的路径。

- Linux:起始节点为根目录。
- Windows:起始节点为某个磁盘的盘符。

### 2.4 命令提示行

XXXX@XXXX：~/XXX$

比如：[margaret@localhost /]$

第一个XXXX:用户名。可以用whoami查看。

第二个XXXX:主机名。

冒号后面的字符串：当前用户所在的工作目录。~表示当前用户所在的家目录。

$:表示当前是普通用户。#表示是root用户。

## 3 命令解析器

### 3.1 工作原理

命令解析器在Linux操作系统中就是一个进程，它的名字叫做bash，通常我们更习惯称之为shell（即sh）。

- 在Linux中有一个叫做PATH的环境变量，里边存储了一些系统目录（Windows也有，叫Path）

  ```shell
  #通过echo命令可以查看环境变量PATH中的值，在shell中变量名前加$就是取值
  [margaret@localhost /]$ echo $PATH
  /opt/rh/devtoolset-7/root/usr/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin:/usr/local/git/bin:/home/margaret/.local/bin:/home/margaret/bin
  ```

![image-20230801225540355](E:/%E8%87%AA%E5%AD%A6/learnLinux/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.assets/image-20230801225540355.png)

- 命令解析器需要依次搜索PATH中的各个目录，检查这些目录中是否有用户输入的指令
  - 如果找到了，执行该目录下的可执行程序，用户输入的指令就被执行完毕了
  - 如果没有找到，继续搜索其他目录，最后还是没有找到，会提示命令找不到，因此无法被执行

### 3.2 命令提示快捷键

| 快捷键           | 功能                    | 备注                                              |
| ---------------- | ----------------------- | ------------------------------------------------- |
| Tab              | 命令自动补齐            | 在终端输入某个命令的前一个或若干个字符，再按Tab键 |
| Ctrl+p           | 显示输入的上一个命令    | 从输入的最后一个命令往前倒，也可用⬆键             |
| Ctrl+n           | 显示输入的下一个命令    | 也可以使用⬇键                                     |
| Ctrl+a           | 光标移动命令行行首      | 也可以使用Home键                                  |
| Ctrl+e           | 光标移动命令行行尾      | 也可以使用End键                                   |
| Ctrl+u           | 删除光标前的部分字符串  | 无                                                |
| Ctrl+k           | 删除光标后的部分字符串  | 无                                                |
| ➡                | 光标向右移动一个字符    | 无                                                |
| ⬅                | 光标向左移动一个字符    | 无                                                |
| Backspace/Delete | 删除光标前/后的一个字符 | 无                                                |

## 4 Linux命令

### 4.1 文件管理命令

#### **4.1.1 cd命令**

切换工作路径。

- cd 目录名。目录名可以是绝对路径，也可以是相对路径。
- 通过cd也可以进行邻近的两个目录之间的切换。（cd -）。适用于需要在两个很长的目录间频繁切换的场景。

#### 4.1.2 **ls命令**

打印指定文件的信息，如果是目录，显示对应目录中有哪些子文件，语法格式格式如下：

```shell
$ls [args]  #查看当前目录
$ls [args] 目录名 #查看指定目录
$ls [args] 文件名 #查看某个文件的信息
```

- 显示所有文件：给ls 添加a参数，显示所有文件（包括隐藏文件，在Linux中文件名前面有.的一般是有隐藏属性的）。
- 显示文件的详细的属性信息。ls -l。
  - 文件类型（第一个字符）：
    - **-：**普通的文件，在Linux终端中没有执行权限的白色，压缩包为红色，可以执行程序为绿色。
    - **d:**目录（directory）,在Linux终端中为蓝色字体，如果目录的所有权限是开放的，有绿色的背景色。
    - **l:**软连接文件（link），相当于windows中的快捷方式，在Linux终端中为淡蓝色（青色）字体。
    - **c:**字符设备（char）,在Linux终端中为黄色字体。
    - **b:**块设备（block），在Linux终端中为黄色字体。
    - **p:**管道文件（pipe），在Linux终端中为棕黄色字体。
    - **s:**本地套接字文件（socket），在Linux终端中为粉色字体。
  - 用户类型：在Linux中有三大类用户：**文件所有者、文件所属组用户、其他人**，我们可以对同一个文件给这三种人设置不同的操作权限，用于限制用户对文件的访问。
    - **文件所有者：**Linux中的所有文件都有一个所有者，就是文件的主人。
    - **文件所属组：**
      - 文件的主人属于哪个组，这个文件默认也就属于哪个组。
      - 用户组中可以有多个用户，这些组中的其他用户和所有者权限可以是不一样的。
    - **其他人**
  - 文件权限：Linux中不同的用户可以对文件拥有不同的操作权限，权限一共有4种：**读权限、写权限、执行权限、无权限**。
    - 读权限：用r表示，即read。
    - 写权限：用w表示，即write。
    - 执行权限：用x表示，即excute。有执行权限才能打开目录。
    - 没有任何权限：用-表示。
  - 硬链接计数：硬链接只是多了一个新的文件名，并不发生拷贝。拷贝文件不仅多了新的文件名而且对磁盘上的数据进行了拷贝。（ln 文件A 文件B  创建硬链接）
  - 其他属性：文件所有者 文件属于哪个组 当前文件大小（如果当前文件是目录，仅仅指目录所占磁盘空间大小，不包含文件内部内容大小） 文件的修改日期 当前文件的名字
- 如果是文件是目录，就在名字后面加上/，如果不是，就正常。ls -F。
- 参数可以组合使用，比如ls -lF。ls -lh。文件属性信息中大小用比较友好的方式显示。

#### 4.1.3 创建删除目录

- **创建目录：**创建目录分为两种，一种是创建单个目录，另一种是一次性创建多重目录，使用的命令是mkdir，后边参数是要创建的目录的名字，如果是多层目录需要添加参数-p。创建的目录所在的路径可以是相对路径，也可以是绝对路径。

  ```shell
  #单层目录
  $ mkdir 新目录的名字
  
  #多层目录
  $ mkdir parent/child/baby1/baby2 -p
  ```

  note:可以通过tree查看目录层级结构

- **删除目录：**如果要删除已存在的路径有两种方式，可以用rmdir或者rm。

  - rmdir：只能删除空目录，不好用。
  - rm:可以删除文件也可以删除目录，如果删除的是目录，需要添加参数-r，意思是递归（recursion）。

  rm命令还有另外两个经常用的参数：

  - -i:shan除的时候给提示
  - -f:强制删除文件，没有提示直接删除，且不能恢复，慎用
    - rm aa/* rf 删除aa里面的文件

#### 4.1.4 cp命令

cp就是copy，使用这个命令可以拷贝文件，也可以拷贝目录。

- 拷贝文件=》文件不存在，就得到新文件，文件存在就覆盖。

  ```shell
  # 语法：cp 要拷贝的文件 得到的文件
  cp 文件A 文件B
  ```

- 拷贝目录=》目录不存在，得到新目录，该目录被拷贝到存在的目录中。

  ```shell
  #拷贝目录需要参数 -r
  # 场景1、2：目录A通过拷贝得到目录Ｂ
  cp 目录A 目录B -r
  #场景3：把A目录里的某一个或者多个文件拷贝到B目录中
  $ cp A/a.txt B #拷贝A目录中的a.txt到目录B中
  $ cp A/* B-r  #拷贝A目录中的所有文件到目录B中，不能确定A目录中是不是有子目录，因此需要加-r
  ```

#### 4.1.5 mv命令

mv就是move，这个Linux命令既可以移动文件所在目录，也可以给文件改名。

- 文件的移动

  ```shell
  # 语法：mv 要移动的文件 目录
  #有一个文件A，移动到目录B中
  ＃其中A可以是文件也可以是目录，B必须是目录而且必须是存在的
  $ mv A B
  ```

- 文件改名

  ```shell
  # 语法：mv 要改名的文件 新名字（原来是不存在的，这点很重要）
  # 其中A可以是文件，也可以是目录并且是存在的，B必须是原来不存在的
  $ mv A B
  ```

- 文件覆盖

  ```shell
  # 语法：mv 存在文件A 存在的文件B
  # 其中A是文件（非目录）并且是存在的，B也是一个文件（非目录）并且也存在
  # A文件的内容覆盖B文件的内容，A文件被删除，只剩下B文件
  $ mv A B
  ```

#### 4.1.6 查看文件的内容

如果要查看文件内容，方式有很多。最常用的是vim,下面介绍一下vim以外的一些方式：

- **cat**。该命令可以将文件内容显示到终端，由于终端是由缓存的，所以能显示的字节数是受限制的。如果文件数据太大就不能完全显示出来了，因此该命令只适合查看比较小的文件内容。

  ```shell
  $ cat 文件名
  ```

- **more:**该命令要比cat高级一点，我们可以以翻屏的方式查看文件中的内容，使用方式如下：

  ```shell
  $ more 文件名
  # 快捷键
  -回车：显示下一行
  -空格：向下滚动一屏
  -b：返回上一屏
  -q:推出more
  ```

- **less:**该命令跟more命令差不多，我们可以以翻屏的方式查看文件中的内容，使用方式如下：

  ```shell
  $ less  文件名
  #快捷键
   -b ：向上翻页
   -空格：向后翻页
   -回车：显示下一行
   -上下键：上下滚动
   -q:退出
  ```

- **head：**使用该命令查看文件头部的若干行信息，使用方法如下：

  ```shell
  #默认显示文件的前10 行
  $ head 文件名
  # 执行显示头部的前多少行
  $ head -行数 文件名
  ```

- **tail:**使用改命令可以查看文件尾部的若干行信息，使用方式如下：

  ```shell
  # 默认显示文件的后10行
  $ tail 文件名
  #指定显示尾部的最后多少行
  $ tail -行数 文件名
  ```

#### 4.1.7 链接的创建

链接分为两种类型：软链接相当于windows 的快捷方式，硬链接并不会进行拷贝，只是多出了一个新的文件名并且硬链接数会加1。

- **软链接：**

  ```shell
  # 语法：ln -s 源文件路径 软链接文件的名字（可以带路径）
  
  #查看目录文件
  [root@dyq ~/margaret]#ll
  total 8
  drwxr-xr-x 3 root root 4096 Jan 25 17:27 get
  -rw-r--r-- 1 root root 37 Jan 25 17:26 opepiece.txt
  
  #给onepiece.txt创建软链接，放到子目录get中
  [root@dyq ~/margaret]#ln -s /root/margaret/onepiece.txt get/link.lnk
  [root@dyq ~/margaret]#ln get
  total 4
  lrwxrwxrwx 1 root root 24 Jan 25 17:27 link.lnk -> /root/margaret/onepiece.txt
  drwxr-xr-x 2 root root 4096 Jan 24 21:37 onepiece
  ```

  在创建软连接的时候，命令中的源文件路径建议使用绝对路径，这样才能保证创建出的软链接文件在任意目录中移动都可以访问到链接的那个源文件。 

- **硬链接：**

```shell
# 语法：ln 源文件 硬链接文件的名字（可以带路径）
```

硬链接和软链接不同，它是通过文件名直接找对应的硬盘地址，而不是基于路径，因此源文件使用相对路径即可，无需为其定制绝对路径。**目录是不允许创建硬链接的。**

#### 4.1.8 文件属性

##### 4.1.8.1  修改文件权限

文件权限是针对文件所有者、文件所属组用户、其他人这三类人而言的，对应的操作指令是chmod。设置方式也有两种，分别为**文字设定法**和**数字设定法**。

文字设定法是通过r\w\x\\-来描述用户对文件的操作权限。

数字设定法是通过0\1\2\3\4\5\6\7来描述用户对文件的操作权限。

- **文字设定法：**

  ```shell
  # chmod
  #语法格式：chmod who [+|-|=] mod 文件名
          -who:
          	-u :user ->文件所有者
          	-g :group ->文件所属组用户
          	-o :other ->其他
          	-a :all,以上三类人 u+g+o
           - 对权限的操作：
           	+： 添加权限
           	-： 去除权限
           	=： 权限的覆盖
           -mod:权限
           	r:read.读
           	w：wite,写
           	x:execute,执行
           	-：没有权限
   eg:chmod a=rwx b.txt     chmod u-x b.txt   chmod go-wx b.txt
  ```

- **数字设定法：**

  ```shell
  #语法格式：chmod [+|-|=] mod 文件名
  		 - 对权限的操作：
           	+： 添加权限
           	-： 去除权限
           	=： 权限的覆盖，等号可以不写
           -mod:权限描述，所有权限都放开是7
           	-4:read.r
           	-2：wite,w
           	-1:execute,x
           	-0：没有权限
  # 分解：chmod 0567 a.txt
  0            5                      6                       7
  八进制    文件所有者            文件所属组用户              其他人
            r+x                   r+w                    r+w+x
  #文件所有者去掉执行权限，所属组用户去掉写权限，其他人去掉读+写权限
  $ chmod -123 c.txt
  ```

##### 4.1.8.2 修改文件所有者

操作命令是chown。因为修改文件所有者是跨用户操作，普通用户没有这个权限，需要借助管理员权限才能完成操作。

**普通用户借助管理员权限执行某些shell命令，需要在命令前加关键字sudo。但是普通用户默认没有使用sudo的资格，需要修改/etc /sudoers文件。**

```shell
#语法1：只修改所有者
$ sudo chown 新的所有者 文件名

#语法2：同时修改所有者和所属组
$ sudo chown 新的所有者：新的组名 文件名
```

##### 4.1.8.3 修改文件所属组

```shell
#语法1：只修改所有者
$ sudo chgrp 新的组 文件名
```

#### 4.1.9 其他命令

##### 4.1.9.1 tree命令

以树状结构显示目录。

```shell
# 语法格式
tree #以树状结构显示
tree [-L n] #查看当前的目录结构，n为显示的目录层数 tree -L 1
tree 目录名 [-L n] #查看指定目录结构，n为显示的目录层数
```

##### 4.1.9.2 pwd命令

显示当前用户的工作目录，没有参数。

##### 4.1.9.3 touch命令

使用touch命令可以创建一个新的空文件，如果指定的文件是已存在的，只会更新文件的修改日期，对内容没有任何影响。

```shell
$ touch 文件名
```

##### 4.1.9.4 which命令

which命令可以查看要执行的命令所在的实际路径，命令解析器工作的时候也会搜索这个目录。需要注意的是该命令只能查看非内建的shell指令所在的实际路径，有些命令是直接写到内核中，无法查看。我们使用到的大部分shell命令都是放在系统/bin或者/usr/bin目录下。

##### 4.1.9.5 重定向命令

关于重定向使用最多的就是输出重定向，顾名思义就是修改输出的数据的位置，通过重定向操作我们可以非常方便的进行文件的复制，或者文件内容的追加。输出重定向使用的不是某个关键字而是符号>或者>>。

- \>：将文件内容写入到指定文件中，如果文件中已有数据，则会使用新数据覆盖原数据。

- \>>:将输出的内容追加到指定的文件尾部。

  ```shell
  #输出重定向举例：printf默认是将数据打印到终端，可以修改默认的输出位置重定向到某个文件中。
  #关键字：>
  #执行一个shell命令，获得一个输出，这个输出默认显示到终端，如果要将其保存到文件中，就可以使用重定向
  #如果当前目录下test.txt存在，会被覆盖。不存在，会被创建。
  $date > test.txt
  #日期信息被写入到文件test.txt中
  
  #如果不希望被覆盖，而是追加，需要使用>>
  $date >> test.txt
  ```

  ps：echo 输出到终端。 echo相当于printf。

### 4.2 用户操作命令

#### 4.2.1 切换用户

Linux是一个多用户的操作系统，可以同时登录多个用户，因此很多时候需要在多个用户间切换，用户切换需要`su 用户名` 或者`su - 用户名`。使用su只切换用户，当前的工作目录不会变化。使用su -不仅会切换用户也会切换工作目录，工作目录切换为当前用户的家目录。

从用户A切换到用户Ｂ又想返回去可以使用exit。

#### 4.2.2 添加删除用户

##### 4.2.2.1 添加用户

作为一个普通用户没有给系统添加新用户的权限，如果想要添加新用户可以先切换到root用户，或者基于普通用户为其添加管理员权限来完成新用户的添加。添加新用户需要`adduser或者useradd`命令来完成。

**推荐使用adduser**

```shell
$ sudo adduser 用户名
```

![image-20230808212750325](E:/%E8%87%AA%E5%AD%A6/learnLinux/Linux%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B.assets/image-20230808212750325.png)

验证用户创建成功：

- 方法一：通过`ls /home`查看。
- 方法二：通过切换用户的方式查看。
- 方法三：查看配置文件。`vim /etc/passwd`搜索创建后的用户名，如果能搜索到说明创建出来了。

##### 4.2.2.2 删除用户

删除用户并不是将/home下的用户家目录删除就完事儿了，我们需要使用`userdle`命令才能删除用户在系统中的用户ID和所属组ID等相关信息，==但是需要注意的是有些Linux版本中用户虽然被删除了，但是它的家目录没有被删除，需要我们手动将其删除。==

```shell
# 删除用户，添加参数-r，就可以一并删除用户的家目录了
$sudo userdel 用户名 -r
# 使用deluser不能添加参数-r，家目录不能被删除，需要使用rm命令删除用户的家目录
$rm /home/用户名
```

**注：**由于Linux版本很多，删除用户对应的操作指令不是唯一的，经测试在centos版本只支持userdel命令，在ubuntu中既支持userdel命令，也是想deluser命令。

#### 4.2.3 添加删除用户组

默认情况下，只要创建新用户就会得到一个同名的用户组，并且这个用户属于这个组。一般情况况下不需要创建新的用户组，如果有需求可以使用`groupadd`添加用户组，使用`groupdel`删除用户组。该操作也需要借助管理员权限。

```shell
# 基于普通用户创建新的用户组
$ sudo groupadd 组名
# 基于普通用户删除已经存在的组名
$ sudo groupdel 组名
```

可以用过查看`/etc/group`文件，验证用户添加删除组是否成功了

在Ubuntu中groupadd/addgroup以及groupdel/delgroup都行，而centos支持groupadd/groupdel。

#### 4.2.4 修改用户密码

修改用户密码有几种情况：

- 当前用户修改自己的密码。默认是有权限操作的。
- 当前普通用户修改其他用户密码。默认没有权限，需要借助管理员权限才能完成操作。
- 当前普通用户修改root用户密码。默认没有权限，需要借助管理员权限才能完成操作。
- root用户修改其他用户密码，默认有权限，可以直接修改。

修改密码需要使用`passwd`命令。当创建了一个普通用户却没有提示指定密码，或者忘记了用户密码都可以通过该命令来实现自己重置密码的需求。

```shell
#修改当前用户
$passwd

#修改非当前用户密码
$sudo passwd 用户名

#修改root
$sudo passwd root
```

### 4.3 使用工具压缩和解压缩

本篇主要讲解基于Linux的常用压缩包操作，格式包含：==.tar.gz,.tgz,.tar.bz2,.zip,.rar,.tar.xz==

#### 4.3.1 tar

在Linux中默认自带两个原始的压缩工具分别是`gzip`和`bzip`,但是他们都有先天的缺陷，==不能打包压缩文件，每个文件都会生成一个单独的压缩包，并且压缩之后不会保留源文件==

Linux中自带一个打包工具，叫做`tar`，默认情况下，该工具的是不能进行压缩操作的，在这种情况下`tar`和`gzip`和`bzip`就联姻了，各自发挥优势，Linux最强大的打包压缩工具至此诞生。

我们在使用tar进行压缩和解压缩的时候，只需要指定相对应的参数，其内部就会调用对应的压缩工具`gzip`或者`bzip`完成指定的操作。

##### 4.3.1.1 压缩（.tar.gz .tar.bz2 .tgz）

如果使用`tar`完成文件压缩，涉及的参数如下，在使用过程中参数没有先后顺序：

- **c:**创建压缩文件
- **z:**使用`gzip`的方式进行文件压缩
- **j:**使用`bzip2`的方式进行文件压缩
- **v:**压缩过程中显示压缩信息，可以省略不写
- **f：**指定压缩包的名字

一般认为.tgz文件就等同于.tar.gz文件，因此他们的压缩方式是相同的。

```shell
#语法
$ tar 参数 生成的压缩包的名字 要压缩的文件（文件或目录）

#备注：关于生成的压缩包的名字，建议使用标准后缀，方便识别：
		——压缩使用gzip方式，标准后缀格式为:.tar.gz
		——压缩使用bzip2方式，标准后缀为:.tar.bz2
```

举例：使用gzip的方式进行文件压缩。

```shell
$ tar czvf all.tar.gz config/ temp/ enhlish.txt
```

##### 4.3.1.2 解压缩（.tar.gz .tar.bz2 .tgz）

如果使用tar进行文件解压缩，涉及的参数如下，在使用过程中参数没有前后顺序

- **x:**释放压缩的文件内容
- **z:**使用`gzip`的方式进行文件压缩，压缩包后缀为`.tar.gz`
- **j:**使用`bzip2`的方式进行文件压缩，压缩包后缀为`.tar.bz2`
- **v:**解压缩过程中显示解压缩信息
- **f:**指定压缩包的名字

使用以上参数是将压缩包解压到当前目录，如果需要解压到指定目录，需要指定参数`-C`,一般认为`.tgz`文件等同于`.tar.tgz`文件，解压缩方式是相同的，解压缩的语法格式如下：

```
#语法1：解压到当前目录中
$ tar 参数 压缩包的名字 

#语法2：解压到指定目录中
$ tar 参数 压缩包名 -C 解压目录 
```

#### 4.3.2 zip

ubuntu:sudo apt install zip    sudo apt install unzip

centos:sudo yum install zip   sudo yum install unzip

##### 4.3.2.1 压缩（zip）

使用zip压缩目录需要注意一点，必须要添加-r参数，这样才能将子目录中的文件一并压缩，如果要压缩的文件中没有目录，该参数就可以不写了。另外使用`zip`压缩文件，会自动生成文件后缀`.zip`，因此不需要额外指定。

```shell
#语法：后自动添加压缩包后缀.zip,如果要压缩目录，需要添加参数 -r,-r可以加到后面，也可以加到前面
$zip -r 压缩包名 要压缩的文件
```

##### 4.3.2.2 解压缩（unzip）

如果压缩包中的文件要解压缩到指定目录要指定参数-d,默认是解压到当前目录中。

```shell
#语法1：解压到当前目录中
$unzip 压缩包名

#语法2：解压到指定目录中，需要添加参数-d
$unzip 压缩包名 -d 解压目录
```

#### 4.3.3 rar

rar在Linux中并不常用，这是windows中常用的压缩格式，如果想要在Linux压缩和解压缩这种格式的文件需要额外安装对应的工具。

Ubuntu：sudo apt install rar

centos:wget 光放下载地址      解压下载得到的文件  将解压的目录移动到/opt目录中（因为/opt是软件安装目录，移动是为了方便管理）

给/opt/ar目录中的可执行程序添加软链接，方便命令解析器可以找到该压缩命令

（ln -s /opt/rar/rar    /usr/local/bin/rar      ln-s /opt/rar/unrar   /usr/local/bin/unrar）

##### 4.3.3.1 压缩(.rar)

使用`rar`压缩过程的注意事项与`zip`是一致的。如果压缩的是目录，需要指定参数-r，如果只压缩文件就不需要添加了。压缩过程中需要使用参数a（archive）压缩归档的意思。rar在压缩的过程中会自动添加后缀，名字为.rar。

```shell
#语法：
$rar a 压缩包名 要压缩的文件 [-r]
```

##### 4.3.3.2 解压缩（.rar）

解压缩`.rar`格式的文件的时候，可以使用`rar`也可以使用`unrar`，操作方式是一样的，需要添加参数-x，默认是将压缩包的内容释放到当前目录中，如果要释放到指定目录直接指定解压目录名即可，不需要使用任何参数。

```shell
#解压缩：需要参数x
#语法：解压缩到当前目录中
$ rar/unrar x 压缩包名字
#语法：解压缩到指定目录中
$ rar/unrar x 压缩包名字 解压目录
```

#### 4.3.4 xz

`.xz`格式文件的压缩和解压缩都相对比较麻烦，通过一个命令是玩不成对应的操作的，需要通过两步操作才行，并且操作过程中需要使用`tar`工具进行打包，压缩使用的是`xz`工具。

##### 4.3.4.1 压缩（.tar.xz）

创建文件的步骤如下，首先，将要压缩的文件打包`tar cvf xxx.tar files`,然后再对打包文件进行压缩`xz -z xxx.tar`，这样我们就可以得到一个打包之后的压缩文件了。使用`xz`工具压缩文件的时候需要添加参数`-z`

```shell
#语法：
$tar cvf xxx.tar 要压缩的文件
$xz -z xxx.tar 
```

##### 4.3.4.2 解压缩（.tar.xz）

使用`xz`工具进行解压缩需要使用参数-d。

```shell
#语法：
$xz -d xxx.tar.gz
$tar xvf xxx.tar
```

### 4.4 文件搜索命令

#### 4.4.1 find

`find`是Linux中一个搜索功能非常强大的工具，他的主要功能是根据文件的属性，查找对应的磁盘文件，比如说我们常用的一些属性`文件名，文件类型，文件大小，文件的目录深度`等，如果想要通过属性对文件进行搜索，只需要指定出属性对应的参数就可以了。

##### 4.4.1.1 文件名（- name）

根据文件名进行搜索的方式有两种：==精确查询==和==模糊查询==，关于模糊查询要使用对应的通配符，常用的有两个，分别是*和？。其中`*`可以匹配零个或多个字符，`?`用于匹配单个字符。

如果进行模糊查询，建议将带有通配符的文件名写到引号中（单引号或者双引号均可）。

如果要根据文件名进行搜索，需要参数`- name`

```shell
$find 搜索的路径 -name 要搜索的文件名
```

ctrl+c退出搜索

##### 4.4.1.2 文件类型（-type）

Linux 中有七种文件类型：

|    文件类型    | 类型的字符描述 |
| :------------: | :------------: |
|  普通文件类型  |       f        |
|    目录类型    |       d        |
|   软链接类型   |       l        |
|  字符设备类型  |       c        |
|   块设备类型   |       b        |
|    管道类型    |       p        |
| 本地套接字类型 |       s        |

```shell
#语法格式
$ find 搜索的路径 -type 文件类型
```

##### 4.4.1.3 文件大小（size）

关于文件大小的单位有很多，可以根据实际需求选择，常用的分别有`k（小写）、M(大写)、G（大写）`。在进行文件大小判断的时候，需要指定相应的范围，涉及符号有两个分别为：加号+和减号-。

```shell
#语法格式：
$ find 搜索的路径 -size [+|-]文件大小
	-文件大小需要加单位
		-k(小写)
		-M(大写)
		-G(大写)
```

==文件大小的区间划分非常重要：==

- -size -4k:[0k,4-1k],表示一个区间，大于等于0并且小于等于3k
- -size 4k:表示的区间是(4-1k,4k],大于3k,小于等于4k
- -size +4k:（4k,+无穷），表示搜索大于4k的文件

可以串写，比如`find ./ -size +1k -size -4k`代表搜当前目录下大于1k小于等于3k的文件

##### 4.4.1.4 目录层级

在搜索某些属性的时候，可以指定只搜索某几层目录，相关的参数有两个，分别为：`-maxdepth`和`-mindepth`。这两个参数不能单独使用，必须和其他属性一起使用，也就是搜素某几层目录中满足条件的文件。

- -maxdepth:最多搜索到第多少层目录。
- -mindepth:至少从第多少层开始搜索。

如果要基于目录层级搜索，一定要先写maxdepth或者mindepth,之后再写文件属性。比如：

```shell
#查找文件，从根目录开始，最多搜索5层，这个文件叫做*.txt
$find / -maxdepth 5 - name "*.txt"

#查找文件，从根目录开始，至少从第5层开始搜索，这个文件叫做*.txt
$find / -mindepth 5 - name "*.txt"
```

##### 4.4.1.5 同时执行多个操作

在搜索文件的时候，如果想在一个`find`执行多个操作，通过使用管道(|)的方式是行不通的。

###### exec

`-exec`是find的参数，可以在exec参数后面添加其他需要被执行的shell命令。

find添加了exec参数之后，命令的尾部许哟啊加一个后缀`{} \;`,注意`{}`和`\`  之间需要一个空格。

在参数`-exec`后添加的shell命令处理的都是find搜索之后的结果，find的结果会作为新添加的shell命令的输入，最后在终端上输出最终结果。

```shell
#语法
$find 路径 参数 参数值 -exec shell命令2 {} \;
```

命令的使用效果演示：

```shell
#搜索最多两层目录，文件后缀为.txt的文件。搜索到满足条件的文件后，在继续查看文件的详细信息
$find ./ -maxdepth 2 -name "*.txt" exec ls -l {} \;
```

###### ok

ok与exec使用方式相似，只不过ok是交互式的，在处理`find`的结果的时候，会向用户发起询问，比如在删除搜素结果的时候，为了保险起见，就需要询问机制。

```shell
#语法
$find 路径 参数 参数值 -ok shell命令2 {} \;
```

###### xargs

使用`find`的`-exec`参数的时候，需要在指定的子命令尾部添加几个特殊字符`{} \;`一不下心就容易写错，我们可以使用`xargs`替换掉`-exec`参数，而且在处理数据的时候`xargs更高效`。有了`xargs`的加持我们就可以在`find命令中直接使用管道完成前后命令的数据传递。

```shell
#在find中使用xargs关键字我们就可以使用管道了，否则使用管道也不起作用
#将find搜索的结果通过管道传递给后边的shell命令继续处理
$find 路径 参数 参数值 | xargs shell 命令2
```

#### 4.4.2 grep

grep用于查找文件内容中符合条件的字符串。`grep`命令中有几个常用参数：

- `-r`:如果需要搜索目录中的文件内容，需要进行递归操作，必须指定该参数。
- `-i`:对应搜索的关键字，忽略字符大小写的差别
- `-n`：在显示符合样式的那一行前，标出改行的列数编号

```shell
#语法格式 引号可以是单引号也可以是双引号
$grep "搜索的文件内容" 搜索的路径/文件 参数
```

#### 4.4.3 locate

我们可以将`locate`看作是一个简化版的`find`，使用这个命令我们可以根据文件名搜素本地的磁盘文件，但是locate的效率要比find高很多。原因在于他不搜索具体目录，而是搜索一个本地的数据库文件，这个数据库中含有本地所有文件信息。Linux自动创建这个数据库，每天更新一次，所以使用locate命令差不到最新变动过的文件。为了避免这种情况，`可以在使用locate之前，先使用updatedb命令，手动更新数据库`

```shell
#使用管理员权限更新本地数据库文件
$sudo updatedb
```

locate有一些常用参数：

- **搜索所有目录下以某个关键字开头的文件**：

  ```shell
  $ locate test #搜索目录下以test开头的文件
  ```

- **搜索指定目录下以某关键字开头的文件，指定目录必须要使用绝对路径**

  ```shell
  $ locate /home/robin/test #指定搜索目录是/home/robin
  ```

- **搜索文件的时候，忽略文件名大小写，使用参数-i**

  ```shell
  $locate TEST -i
  ```

- **列出前n个匹配到的文件名称或路径名称**

  ```shell
  $locate test -n 5 #显示5条信息
  ```

- **基于正则表达式进行文件名匹配，查找符合条件的文件，使用参数-r**

  ```shell
  #使用该参数，需要有正则表达式基础
  $locate -r "\.cpp$" #搜以.cpp结尾的文件
  ```

==正则表达式科普==

- 在正则表达式中.可以匹配任意一个非\n的单字符
- 上边的命令中使用转义字符\对特殊字符.转义，就得到了普通字符.
- 在正则表达式中$放到字符尾部，表示字符串必须以这个字符结尾，上边的命令中修饰的字符是p
- 正则表达式中的字符c和后边的字符p需要进行字节匹配，没有特殊含义

# vim

## 1 vim的安装和介绍

ubuntu:sudo apt-get vim

centos:sudo yum install vim

## 2 vim的模式

==三种模式：命令模式、末行模式、编辑模式==，打开vim后，默认进入的是==命令模式==

- 命令模式：在该模式下可以进行==查看文件内容、修改文件、关键字的搜索等操作==。
- 编辑模式：在该模式下主要对===文件内容进行修改和内容添加==。
- 末行模式：在该模式下，可以进行==执行Linux命令、保存文件、进行行的跳转、窗口分屏等操作==。

**编辑模式和末行模式不能直接互相切换**

## 3 命令模式下的操作

vim 文件名

### 3.1 保存退出

按两次Z(大写)，也就是先按住Shift键，然后连续zz

### 3.2 代码格式化

gg=G   可以对齐代码，让代码更美观

### 3.3 光标移动

在vim中可以通过键盘上的方向键移动光标。还有更简便的操作方式是使用hjkl分别实施左移下移上移右移。

除此之外，还有一些快捷键可以实现光标的快速跳转，常用的有：



| 快捷键 | 功能             | 备注                                         |
| ------ | ---------------- | -------------------------------------------- |
| 0      | 光标移动到行首   | 无                                           |
| $      | 光标移动到行尾   | 选按两个键：shift+4                          |
| gg     | 光标移动到文件头 | 第一行的开始                                 |
| G      | 光标移动到文件尾 | 最后一行的开始                               |
| nG     | 行跳转           | n代表要跳到哪行                              |
| n+回车 | 相对跳转n行      | 从光标所在当前行往下跳n行，n对应的是一个整数 |

### 3.4 删除命令

其实就是剪切。

| 快捷键  | 功能               | 备注                                               |
| ------- | ------------------ | -------------------------------------------------- |
| x(小写) | 删除光标后的字符   |                                                    |
| X(大写) | 删除光标前的字符   |                                                    |
| dw      | 删除单词           | 要把光标移动到第一个字母上删除，否则只能删除一部分 |
| d0      | 删除光标前的字符串 | 从字符串开头到光标当前位置的字符拆被删除了         |
| d（D）$ | 删除光标后的字符串 | 从光标当前位置到字符串尾部的字符串被删除了         |
| dd      | 删除光标所在行     | 无                                                 |
| ndd     | 删除n行            | 从光标当前所在行开始删除n行                        |

### 3.5 撤销和反撤销

| 快捷键 | 功能   | 备注                    |
| ------ | ------ | ----------------------- |
| u      | 撤销   | 相当于windows的ctrl+z   |
| ctrl+r | 反撤销 | 相当于windows中的ctrl+y |

### 3.6 复制和粘贴

| 快捷键 | 功能                    | 备注  |
| ------ | ----------------------- | ----- |
| p      | 粘贴到光标所在行的下边  | 小写p |
| P      | 粘贴到光标所在行上边    |       |
| yy     | 复制光标所在行          |       |
| nyy    | 从光标所在行向下赋值n行 |       |

### 3.7 可视模式

在编辑文件的过程中，有时候需要删除或者复制的数据不是整行的，而是行中的一部分，这时候可以使用可视模式进行文本的选择，之后再通过相关的快捷键对所选中的数据进行复制或者删除操作。

有三种方式可以切换到可视模式：

- v:进入字符化的可视模式，文本选择是以字符为单位的
- V:进入行的可视化模式，文本选择是以行为单位的
- ctrl-v:进入块的可视化模式，可以选择一个矩形内的文本
  - 应用：多行代码注释。
    - 通过`ctrl+v`进入块可视化
    - 移动光标上移（k）或者下移（j）,选中多个代码行的开头
    - 选择完毕后按大写的`I`键。此时下方会提示进入“insert”模式，输入你要插入的注释符
    - 最后按ESC键
  - 删除多行注释的方法一样，只不过按d。

进入可视化模式后就可以进行文本的选择和复制了：

| 快捷键 | 功能               | 备注                       |
| ------ | ------------------ | -------------------------- |
| h      | 光标向左移动       |                            |
| j      | 光标向下移动       |                            |
| k      | 光标向上移动       |                            |
| l      | 光标向右移动       |                            |
| d      | 删除（剪切）       | 删除可视模式下选中的数据块 |
| y      | 复制               | 复制可视模式下选中的数据块 |
| p      | 数据粘贴到光标后边 |                            |
| P      | 数据粘贴到光标前边 |                            |

### 3.8 替换

| 快捷键 | 功能                               | 备注 |
| ------ | ---------------------------------- | ---- |
| r      | 替换光标后的单个字符并且只替换一次 |      |
| R      | 替换光标后的多个字符               |      |

### 3.9 查找

在vim的命令模式下一共有三种查找方式，首先需要在键盘上输入对应的字符，然后按回车键vim就会进行关键字匹配，之后就可以通过n或者N进行关键字的替换了。

| 搜索快捷键 | 关键字遍历 | 描述           | 备注                                      |
| ---------- | ---------- | -------------- | ----------------------------------------- |
| /          | n          | 从当前位置向上 |                                           |
|            | N          | 从当前位置向下 |                                           |
| ？         | n          | 从当前位置向上 |                                           |
|            | N          | 从当前位置向下 |                                           |
| #          | n          | 从当前位置向上 | 光标需要先放在被搜索的关键字上，键盘上按# |
|            | N          | 从当前位置向下 |                                           |

### 3.10 查看man文档

```shell
$man man #打开man文档的首页
#退出man文档，直接按键盘上的q即可。
```

| 章节      | 说明                                    |
| --------- | --------------------------------------- |
| section 1 | Linux提供的所有shell命令                |
| section 2 | 系统函数（由内核提供的）                |
| section 3 | 库调函数（程序库中的函数）              |
| section 4 | 特殊文件（通常在/dev目录中可以找到）    |
| section 5 | 系统配置文件格式和约定，比如/etc/passwd |
| section 6 | 游戏                                    |
| section 7 | 杂项（包括宏包和约定）                  |
| section 8 | 系统管理命令（通常仅针对root用户）      |
| section 9 | 内核例程（非标准）                      |

查询的时候章节号是可以省略略的，只是查找到的结果不精确。如果不写章节号，从第一章开始搜索查询的关键字，如果查询到了，直接就结束了。也就是说如果查询的是函数，但是这个函数和某个命令的名字是相同的，查询到第一章搜索就结束了。

如果当前是在vim命令的模式下，我们可以直接跳转到man文档：

- 找到要查看的函数，然后将光标放到该函数上
- 在键盘上依次输入：章节号（可选）+K,就会自动跳转到man文档中了

### 3.11 切换到编辑模式

切换模式的快捷键有很多，不同的快捷键对应的效果不同，效果如下表所示：

| 快捷键 | 功能                                     |
| ------ | ---------------------------------------- |
| i      | 从光标前边开始输入                       |
| a      | 从光标的后边开始输入                     |
| o      | 在光标下边新建行，在新行中输入           |
| s      | 删除光标后边的字符，从删除的位置开始输入 |
| I      | 从当前行首输入                           |
| A      | 从当前行尾开始输入                       |
| O      | 在光标上边创建新行，在新行中输入         |
| S      | 删除当前行，在当前行开始输入             |

文件编辑模式回到命令模式只需要按Esc键即可。

## 4 末行模式下的操作

### 4.1 命令模式到末行模式

从命令模式切换到末行模式只需要在键盘上输入`：`,同时这个符号会出现在窗口的最下端，这时候我们就可以在最后一行输入我们执行的命令了。

从末行模式——> 命令模式

- 按两次Esc
- 在末行模式下执行一个完整指令，执行完毕，自动回到命令模式

### 4.2 保存退出

| 末行模式下输入的命令 | 功能                                              |
| -------------------- | ------------------------------------------------- |
| q                    | 退出，如果退出的时候文件没保存，vim会提示是否保存 |
| q!                   | 直接退出，不保存（强制退出）                      |
| w                    | 保存，不退出                                      |
| wq                   | 保存退出                                          |
| x                    | 保存退出                                          |

### 4.3 替换

在末行模式下可以指定将什么样的内容替换成什么样的内容，并且可以指定替换某一行或者某几行或者是全文替换。

替换对应的指令是`s`并且可以给其指定参数，默认情况下只替换相关行的第一个满足条件的关键字，如果需要替换整行需要添加参数/g。

| 末行模式下的替换命令                      | 说明                                                     |
| ----------------------------------------- | -------------------------------------------------------- |
| s/被替换的关键字/新的关键字g              | 只对光标所在行进行替换                                   |
| 行号1，行号2s/被替换的关键字/新的关键字/g | 【行号1，行号2】是一个从小到大的范围，对这个范围进行替换 |
| %s/被替换的关键字/新的关键字/g            | %代表对所有行进行替换                                    |

### 4.4 分屏

分屏就是将当前屏幕中的窗口以水平或垂直的方式拆分成多个，在不同的子窗口中可以显示同一个文件或者不同文件中的内容，下边介绍一些相关的分屏命令：

| 末行模式下的命令或者快捷键 | 说明                         | 备注                           |
| -------------------------- | ---------------------------- | ------------------------------ |
| sp                         | 水平分屏，多个窗口垂直排列   | 多个窗口中显示同一个文件的内容 |
| vsp                        | 垂直分屏，多个窗口水平排列   | 多个窗口显示同一个文件里的内容 |
| ctrl+w+w                   | 光标在打开的屏幕之间切换     |                                |
| qall                       | 同时退出多个屏幕             |                                |
| wall                       | 同时保存退出多个屏幕         |                                |
| sp 文件名                  | 分屏同时指定打开的文件的名字 | 在新窗口中显示指定的文件的内容 |
| vsp 文件名                 | 分屏同时指定打开的文件的名字 | 在新窗口中显示指定的文件的内容 |

除了在命令模式下分屏，我们也可以在使用vim打开文件的时候直接分屏。

- -o:水平分屏
- -O:垂直分屏

```shell
#水平分屏
$vim -o 文件1，文件2，文件3......
#垂直分屏
$vim -o 文件1，文件2，文件3......
```

### 4.5 行跳转

```shell
:行号 #输入完行号后敲回车
```

### 4.6 执行shell命令

在vim编辑文件的过程中，还可以在末行模式下执行需要的shell命令，在执行shell命令之前需要在前边加一个叹号！

```shell
#语法：
:!shell命令
```

### 4.7 vim配置文件

vim的配置文件叫vimrc，在里边可以设置样式、功能、快捷键等属性。对应的配置文件分为两种，分别是`用户级别``系统级别`.。

- 用户级别的配置文件（~/.vimrc）只对当前用户有效
- 系统级别的配置文件（/etc/vim/vimrc）对所有Linux用户都有效
- 如果两个配置文件都设置了，用户级别的配置文件起作用

# GCC

GNU是Linux下编译工具集，包含==gcc、g++==等编译器，还包括其他工具集，比如ar,nm等。

GCC工具集不仅能编译C/C++语言，还能编译Java\Ada\Pasal\Fortran\Objective-C等语言，GCC可以根据不同的硬件平台进行编译，即能进行交叉编译，在A平台山编译B平台上的程序。

 ## 1 安装GCC

## 2 GCC工作流程

GCC对程序的编译分为四个阶段：==预处理（预编译）、编译和优化、汇编、链接==。GCC编译器可以将这四个步骤合为一个。

- 预处理：在这个阶段主要做了三件事：展开头文件、宏替换、去掉注释行
  - 这个阶段GCC调用处理器来完成，最终得到的是源文件，文本格式
- 编译：这个阶段需要GCC调用编译器对文件进行编译，最终得到一个汇编文件
- 汇编：这个阶段需要ＧＣＣ调用汇编器对文件进行汇编，最终得到一个二进制文件
- 链接：这个阶段需要GCC调用链接器对程序需要调用的库进行链接，最终得到一个可执行的二进制文件

| 文件名后缀 | 说明                           | gcc参数 |
| ---------- | ------------------------------ | ------- |
| .c         | 源文件                         | 无      |
| .i         | 预处理后的C文件                | -E      |
| .s         | 编译之后得到的汇编语言的源文件 | -S      |
| .o         | 汇编后得到的二进制文件         | -c      |

## 3 gcc参数

下面表格列出了常用的一些gcc参数，这些参数在gcc命令中没有位置要求，之只需要在编译的时候将需要的参数指定出来即可。

| gcc编译选项                           | 选项的意义                                                   |
| ------------------------------------- | ------------------------------------------------------------ |
| -E                                    | 预处理的源文件，不进行编译                                   |
| -S                                    | 编译指定的源文件，但是不进行汇编                             |
| -c                                    | 编译、汇编指定的源文件，但是不进行链接                       |
| -o [file1] [file2]/[file2] -o [file1] | 将文件fiel2编译成文件file1                                   |
| -I directory                          | 指定include包含文件的搜索目录                                |
| -g                                    | 在编译的时候，生成调试信息，该程序可以被调试器调试           |
| -D                                    | 在程序编译的时候，指定一个宏                                 |
| -w                                    | 不生成任何警告信息，不建议使用，有些时候警告就是错误         |
| -Wall                                 | 生成所有警告信息                                             |
| -On                                   | n的取值范围：0~3。编译器的优化选项的4个级别，-O0表示没有优化，-O1为缺省值，-O3为优化级别最高 |
| -l                                    | 在程序编译的时候，指定使用的库                               |
| -L                                    | 在编译的时候，搜索的库的路径                                 |
| -fPIC/fpic                            | 生成与位置无关的代码                                         |
| -shared                               | 生成共享目标文件。通常用在建立共享库时                       |
| -std                                  | 指定C方言，如：-std = c99,gcc默认的方言是GNU C               |

gcc  -D的应用：打印日志，把debug的日志放到#if DEBUG  #end if这样的宏里。然后gcc的时候想打印就指定宏DEBUG。

## 4 gcc与g++

**区别：**

1. 在代码编译阶段（第二个阶段）：
   1. 后缀为.c的文件，gcc会把他当作C程序，而 g++当作是C++程序
   2. 后缀为cpp的，两者都会认为是C++程序，C++的语法规则更加严谨一些
   3. g++会调用gcc,对于C++代码，两者是等价的，也就是说gcc 和g++都可以编译C/C++代码
2. 在链接阶段（最后一个阶段）：
   1. gcc和g++都可以自动链接到标准c库
   2. g++可以链接到标准C++库，gcc如果要链接到标准C++库需要加参数-lstdc++
3. 关于_cpluscplus宏的定义
   1. g++会自动定义_cplusplus宏，但是这个不影响它去编译C程序
   2. gcc需要根据文件后缀判断是否需要定义_ cpluscplus宏（规则参考第一条）

综上所述：

1. 不管是gcc还是g++都可以编译C程序，编译程序的规则和参数都相同
2. g++可以直接编译C++程序，gcc编译C++程序需要额外添加参数-lsdc++
3. 不管是gcc还是g++都可以定义_cpluscplus宏

```shell
#编译c程序
$g++ test.c -o test #使用gcc
$g++ test.c -o test #使用g++

#编译c++程序
$g++ test.cpp -o test
$gcc test.cpp -lstdc++ -o test
```

# Linux的静态库和动态库

在项目中使用库一般有两个目的，一个是为了使程序更加简洁不需要在项目中维护太多的源文件，另一方面是为了源代码保密。

我们拿到了库文件（动态库、静态库）之后要想使用还必须有这些库中提供的API函数的声明，也就是头文件，把这些都添加到项目中，就可以快乐的写代码了。

## 1 静态库

在Linux中静态库由`ar`生成，现在静态库已经不想之前那么普遍了，这是由于程序都在使用动态库。关于静态库的命名规则如下：

- 在Linux中静态库以`lib`作为前缀，以`.a`作为后缀，中间是库的名字自己指定即可，即`libxxx.a`
- 在windows中静态库一般以`lib`作为前缀，以`lib`作为后缀，中间库的名字是需要自己指定，即`libXXX.lib`

### 1.1 生成静态链接库

生成静态库，需要先对源文件进行汇编操作（`使用参数-c`）得到二进制格式的目标文件(`.o`格式)，然后通过`ar`工具将目标文件打包就可以得到静态库文件了（libXXX.a）。

使用`ar`工具创建静态库的时候需要三个参数：

- 参数c:创建一个库，不管库是不是存在，都将创建
- 参数s:创建目标文件索引，这在创建较大的库时能加快时间
- 参数r:在库中插入模块（替换）。默认新的成员添加在库的结尾处，如果模块名已经在库中存在，则替换同名的模块。

生成静态链接库的具体步骤如下：

1、需要将源文件进行汇编，得到.o文件，需要使用参数-c

```shell
#执行如下操作，默认生成二进制的.o文件
#-c 参数位置没有要求
$gcc 源文件(*.c) -c
```

2、将得到的.o进行打包，得到静态库

```shell
$ar rcs 静态库的名字(libxxxx.a) 原材料(*.o)
```

3、发布静态库

```shell
#发布静态库
	1、提供头文件 **.h
	2、提供制作出来的静态库 libxxxx.a
```

### 1.2 静态库的使用

拿到静态库文件后写测试函数并运行测试函数，gcc 时必须使用到两个参数，一个L，一个l。L指定动态库的搜索路径，l指定动态库的名称（名称需要掐头去尾，比如libcal.a需要写为cal）

## 2 动态库

动态链接库是目标文件的集合，目标文件在动态链接库中的组织方式是按照特殊形式形成的。库中函数和变量的地址使用的是相对地址（静态库中使用的是绝对地址），其真实地址是在应用程序加载动态库时形成的。关于动态库的命名规则如下：

- 在Linux中动态库以`lib`作为前缀，以`.so`作为后缀，中间是库的名字自己制定即可，即：`libxxx.so`
- 在windows中动态库一般以`lib`作为前缀，以`dll`作为后缀，中间是库的名字需要自己指定。

### 2.1 生成动态链接库

生成动态链接库是直接使用 `gcc`命令并且需要添加`-fPIC(fpic)`以及`-shared`参数。

- ==-fPIC或-fpic==参数的作用是==使得gcc生成的代码是与位置无关的，也就是使用相对位置==
- ==-shared参数==的作用是告诉编译器生成一个动态链接库

生成动态链接库的具体步骤如下：

1、将源文件进行汇编操作，需要使用参数-c，还需要添加额外参数-fpic/-fPIC

```shell
#得到若干个.o文件
$gcc 源文件(*.c) -c fpic
```

2、将得到的.o文件打包成动态库，还是使用gcc,使用参数-shared指定生成动态库（位置没有要求）

```shell
$gcc -shared 与位置无关的目标文件（*.o） -o 动态库（libxxx.so）
```

3、发布动态库和头文件

```shell
#发布
	1、提供头文件：xxx.h
	2、提供动态库：libxxx.so
```

### 2.2 解决动态库无法加载问题

#### 2.2.1 库的工作原理

- 静态库如何被加载：在程序编译的最后一个阶段，也就是链接阶段，提供的静态库会被打包到可执行程序中。当可执行程序被执行，静态库中的代码也会一并被加载到内存中，因此不会出现静态库找不到无法被加载的问题。
- 动态库如何被加载：
  - 在程序编译的最后一个阶段，也就是链接阶段：
    - 在gcc命令中虽然指定了库路径（==使用参数-L==）,但是这个路径并没有被记录到可执行程序中，只是检查了这个路径下的库文件是否存在。
    - 同样对应动态库文件也没有被打包到可执行程序中，只是在可执行程序中记录了库的名字。
  - 可执行程序执行起来后：
    - 程序执行的时候会先检测需要的动态库是否可以被加载，加载不到就会提示错误信息
    - 当动态库中的函数在程序中被调用了，这个时候动态库才加载到内存，如果不被调用就不加载
    - 动态库的检测和内存加载操作时由动态链接器来完成的

#### 2.4.2 动态链接器

动态链接器是一个独立于应用程序的进程，属于操作系统，当用户的程序需要加载动态库连接器就开始工作了，很显然动态链接器根本就不知道用户通过gcc编译程序的时候通过参数`-L`指定的路径。那么动态连接器如何搜索某一个动态库呢，按照优先级从高到低的顺序分别是：

- 可执行文件DT_RPATH段
- 系统的环境变量LD_LIBRARY_PATH
- 系统的动态库缓存文件/etc/ld.so.cache
- 存储动态库/静态库的系统目录/lib,/usr/lib等

按照以上四个顺序，依次搜索，找到之后结束遍历，最终还是没找到，动态链接器就会提示动态库找不到的错误信息。可以通过ldd命令查看到动态库是否能被找到。

#### 2.4.3 解决方案

可执行程序生成之后，根据动态连接器的搜索路径，我们可以提供三种解决方案，我们只需要将动态库的路径放到对应的环境变量或者系统配置文件中，同样也可以将动态库拷贝到系统库目录（或者是将动态库的软连接文件放到这些系统库目录中。）

- 方案1：将库路径添加到环境变量LD_LIBRARY_PATH中

  - 1、找到相关的配置文件

    - 用户级别：`~/.bashrc`——>设置对当前用户有效
    - 系统级别：`/etc/profile`——>设置对所有用户有效

  - 2、使用vim打开配置文件

    ```shell
    #自己把路径写进去就行了
    export LIBrary_path = $LIBRARY_PATH:动态库的绝对路径
    ```

  - 3、让修改的配置文件生效

    - 修改了用户级别的配置文件，关闭当前终端，打开一个新的终端配置就生效了

    - 修改了系统级别的配置文件，注销或关闭系统，再开机配置就生效了

    - 不想执行上边的操作，可以执行一个命令让配置重新被加载

      ```shell
      $source ~/.bashrc   (. ~/.bashrc)
      $source /etc/profile (. /etc/profile)
      ```

- 方案2：更新/etc/ld.so.cache文件

  1、找到动态路径的绝对路径（不包括库的名字），比如：`/home/robin/Library/`

  2、使用`vim`修改`/etc/ld.so.conf`这个文件，将上边的路径添加到文件中（独自占一行）

  ```shell
  #1.打开文件
  $sudo vim/etc/ld.so.conf
  #2.添加动态库路径，并保存退出
  ```

  3、更新`/etc.ld.so.conf`中的数据到`/etc/ls.so.cache`中

  ```shell
  #必须使用管理员权限
  $sudo ldconfig
  ```

- 方案3:拷贝动态库文件到系统目录`/lib/`或者`/usr/lib`中（或者将库的软连接文件放进去）

  ```shell
  #库拷贝
  sudo cp /xxx/xxx/libxxx.so /usr.lib
  
  #创建软链接
  sudo ln -s /xxx/xxx/libxxx.so  /usr/lib/libxxx.so
  ```

#### 2.4.4 验证

在启动可执行程序之前，或者在设置了动态库路径之后，我们可以通过一个命令检测程序能不能通过动态库连接器加载到对应的动态库，这个名字叫做`ldd`。

```shell
#语法
$ldd 可执行程序名
```

### 3 优缺点

## 3.1 静态库

- 优点：
  - 静态库被打包到应用程序中加载速度快
  - 发布程序无需提供静态库，移植方便
- 缺点：
  - 相同的库文件数据可能在内存中被加载多份，消耗系统资源，浪费内存
  - 库文件更新需要重新编译项目文件，生成新的可执行程序，浪费时间

## 3.2 动态库

- 优点：
  - 可实现不同进程间的资源共享
  - 动态库升级简单，只需要替换库文件，无需重新编译应用程序
  - 程序员可以控制何时加载动态库，不调用库函数动态库不会被加载
- 缺点：
  - 加载速度 比静态库慢，以现在计算机性能可以忽略
  - 发布程序需要提供依赖的动态库

# makefile

==make是一个命令工具，是一个解释makefile中指令的命令工具==，一般来说，大多数的IDE都有这个命令，比如visual C++的nmake，QtCreater的qmake等。make工具在构造项目的时候需要加载一个叫做`makefile`的文件，makefile关系到了整个工程的编译规则。makefile好处就是自动化编译，一旦写好，只需要一个make命令，整个工程完全自动编译，极大地提高了软件开发的效率。makefile有俩种命名方式`makefile`和`Makefile`,构建项目的时候在哪个目录下执行构建命令`make`这个目录下的makefile文件就会被加载，因此一个项目中可以有多个makefile文件分别位于不同的项目目录中。

## 1  规则

Makefile的框架是由规则构成的，make命令执行时先在Makefile文件中查找各种规则，对各种规则进行解析后运行规则，规则的基本格式为：

```makefile
#每条规则的语法格式
target1,target2,target3...:depend1,depend2,depend3..
	conmand
	......
	......
```

每条规则由三个部分组成，分别是`目标（target）、依赖（depend）和命令（conmand）`

- `命令（conmand）：`当前这条规则的动作，一般情况下这个动作就是一个shell命令
  - 例如：通过某个命令编译文件、生成库文件、进入目录等
  - 动作可以是多个，==每个命令前必须有一个Tab缩进并且独占一行==
- `依赖（depend）:`规则所必需的依赖文件，在规则的命令中可以使用这些依赖。
  - 例如：生成可执行文件的目标文件(*.o)可以作为依赖使用
  - 如果规则的命令中不需要任何依赖，那么规则的依赖可以为空
  - 当前规则中的依赖可以是其他规则中的某个目标，这样就形成了规则间的嵌套
  - 依赖可以根据要执行的命令的实际需求，指定很多个
- `目标（target）:`规则中的目标，这个目标个规则中的命令是对应的
  - 通过执行规则中的命令，可以生成一个和目标文件同名的文件
  - 规则中可以有多个命令，因此可以通过这些命令来生成多个目标文件，所以目标也可以有多个
  - 通过执行规则中的命令，可以只执行一个动作，不生成任何文件，这样的目标被成为伪目标

```makefile
#举例：有源文件a.c b.c c.c head.h,需要生成可执行程序app
##################例1#############################
app:a.c b.c c.c d.c
	gcc a.c b.c c.c d.c -o app
##################例2############################
#有多个目标、多个依赖、多个命令
app,app1:a.c b.c c.c d.c
	gcc a.c b.c -o app
	gcc c.c d.c -o app1
#################例3#############################
#规则之间的嵌套
app:a.o b.o c.o
	gcc a.o b.o c.o -o app
#a.o是第一条规则的依赖
a.o:a.c
	gcc -c a.c
#b.o是第一条规则的依赖
b.o:b.c
	gcc -c b.c
#c.o是第一条规则的依赖
c.o:c.c
	gcc -c c.c
```

## 2 工作原理

### 2.1 规则的执行

==在调用make命令编译程序的时候，make会首先找到Makefile文件中的第1个规则，分析并执行相关的动作==但是需要注意的是，好多时候要执行的命令中使用的依赖是不存在的，如果使用的依赖不存在，这个动作就不会被执行。

对应的解决方案是先将需要的依赖生成出来，我们就可以在makefile中添加新的规则，将不存在的依赖作为这个新的规则中的目标，当这条新的规则对应的命令执行完毕，对应的目标生成了，同时另一条规则中需要的依赖也就存在了。

这样，makefile中的某一条规则在需要的时候，就会被其他的规则调用，直到makefile的第一条规则中的所有依赖全部被生成了，第一条规则中的命令就可以基于这些依赖生成对应的目标文件，make的任务也就完成了。

```makefile
#makefile
#规则之间的嵌套
#规则1
app:a.o b.o c.o
	gcc a.o b.o c.o -o app
#规则2
a.o:a.c
	gcc -c a.c
#规则3
b.o:b.c
	gcc -c b.c
#规则4
c.o:c.c
	gcc -c c.c
```

在这个例子中，如果执行make命令就会根据makefile中的4条规则编译这三个源文件。在解析第一条规则的时候发现里边三个依赖都是不存在的，因此规则对应的命令就不能被执行。

当依赖不存在的时候，make就查找其他的规则，看哪一条是用来生成需要的这个依赖的，找到之后就会执行这条规则中的命令。因此规则2，3，4里的命令会相继被执行，当规则1中依赖全部生成对应文件后，对应的命令也就被执行。

### 2.2文件的时间戳

make命令执行的时候会根据文件的时间戳判定是否执行makefile文件中相关规则的命令。

- 目标是通过依赖生成的，因此正常情况下`目标时间戳>所有依赖的时间戳`，如果执行make命令的时候检测到规则中的目标和依赖满足这个条件，那么规则中的命令就不会被执行。
- 当依赖的文件更新了，文件时间戳也会随之被更新，这时候`目标时间戳<某些依赖的时间戳`，在这种情况下目标文件会通过规则中的命令被重新生成。
- 如果规则中的目标文件不存在，那么规则中的命令肯定被执行。

### 2.3 自动推导

make有自动推导功能，所以并不完全依赖makefile。

